[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Victor Henriques",
    "section": "",
    "text": "Welcome to my website"
  },
  {
    "objectID": "Simulation Results.html",
    "href": "Simulation Results.html",
    "title": "Simulation Results",
    "section": "",
    "text": "The main simulation results of GARCH-based risk measures as summarized as:\n\nIn general, we verify that a smaller sample size add more dispersion and quantile level skewness to the simulated distribution, regardless the scenario (Benchmark High Persistence), estimation method (Bootstrap, QMLE and MLE) and type of innovation (\\(t_{3},t_{8},t_{500}\\)).\nHeavy-tailed (\\(t_{3}\\)) simulation reveals that the estimation of risk measures via QMLE is biased.\n\nThe result is more pronounced in the High Persistence scenario.\nQMLE also divert from both Bootstrap and MLE estimation.\n\nThe distribution of Bootstrap, QMLE and MLE risk measures tends to approximate towards the simulated distribution when we choose thin-tailed distribution (\\(t_{500}\\)), regardless the simulation scenario.\nHeavy-tailed innovations (\\(t_{3}\\)) and high persistence (\\(\\beta = 0.89\\)) maximizes the difference in averages between QMLE and the simulation."
  },
  {
    "objectID": "Simulation Results.html#distribution-of-risk-measures",
    "href": "Simulation Results.html#distribution-of-risk-measures",
    "title": "Simulation Results",
    "section": "Distribution of risk measures",
    "text": "Distribution of risk measures\n\nWe calculate the quantiles, expectiles and extremiles from the standard residuals:\n\nFirst, we compute the risk measures via QMLE at \\(\\tau =\\{1\\%,5\\%,10\\%\\}\\).\nSecond, we compute the risk measures via MLE at \\(\\tau =\\{1\\%,5\\%,10\\%\\}\\).\nThird, we compute the risk measures via bootstrap at \\(\\tau =\\{1\\%,5\\%,10\\%\\}\\).\n\nIn the case of MLE, we estimate the GARCH model with t-Student innovations.\nIn the case of bootstrap, we follow Pascual, Romo, and Ruiz (2006)."
  },
  {
    "objectID": "Simulation Results.html#relative-distribution",
    "href": "Simulation Results.html#relative-distribution",
    "title": "Simulation Results",
    "section": "Relative Distribution",
    "text": "Relative Distribution\n\nFollowing the same strategy, we compute the relative distribution \\(\\xi_{\\tau}^{*} = \\widehat{\\xi}_{\\tau}/\\xi_{\\tau}\\)"
  },
  {
    "objectID": "Simulation Results.html#squared-relative-distribution",
    "href": "Simulation Results.html#squared-relative-distribution",
    "title": "Simulation Results",
    "section": "Squared Relative Distribution",
    "text": "Squared Relative Distribution\n\n\nFollowing the same strategy, we compute the squared relative distribution \\((\\xi_{\\tau}^{*})^{2} = (\\widehat{\\xi}_{\\tau}/\\xi_{\\tau})^{2}\\)"
  },
  {
    "objectID": "Simulation Results.html#simulation-1",
    "href": "Simulation Results.html#simulation-1",
    "title": "Simulation Results",
    "section": "Simulation",
    "text": "Simulation\n\nBenchmark with Gaussian Distribution\n\nConsider the following GARCH(1, 1) process for the returns:\n\n\\[\n\\begin{cases}\n\\epsilon_{t} = \\sigma_{t} \\eta_{t} \\ , \\quad \\eta_{t} \\thicksim t_{500}\\\\\n\\sigma_{t}^{2} = \\frac{20^2}{252} + 0.10\\epsilon_{t-1}^{2} + 0.80\\sigma_{t-1}^{2}\n\\end{cases}\n\\]\ngarch_benchmark_normal <-\n  ugarchspec(\n    mean.model = list(armaOrder = c(0,0), include.mean = FALSE), # ARMA order\n    variance.model = list(model = \"sGARCH\", garchOrder = c(1,1)), # GARCH order\n    distribution.model = \"std\", # Innovation distribution\n    fixed.pars = list(\n      mu = 0, # our mu (intercept)\n      ar1 = 0, # our phi_1 (AR(1) parameter of mu_t)\n      ma1 = 0, # our theta_1 (MA(1) parameter of mu_t)\n      omega = (20^2/252)*(1-0.1-0.8), # our alpha_0 (intercept)\n      alpha1 = 0.1, # our alpha_1 (ARCH(1) parameter of sigma_t^2)\n      beta1 = 0.8, # our beta_1 (GARCH(1) parameter of sigma_t^2)\n      shape = 500)) # d.o.f. nu for standardized t_nu innovations\n\n\nBenchmark with t-Student Distribution\n\nConsider the following GARCH(1, 1) process for the returns:\n\n\\[\n\\begin{cases}\n\\epsilon_{t} = \\sigma_{t} \\eta_{t} \\ , \\quad \\eta_{t} \\thicksim t_{8} \\\\\n\\sigma_{t}^{2} = \\frac{20^2}{252} + 0.10\\epsilon_{t-1}^{2} + 0.80\\sigma_{t-1}^{2}\n\\end{cases}\n\\]\ngarch_benchmark_t <-\n  ugarchspec(\n    mean.model = list(armaOrder = c(0,0), include.mean = FALSE), # ARMA order\n    variance.model = list(model = \"sGARCH\", garchOrder = c(1,1)), # GARCH order\n    distribution.model = \"std\", # Innovation distribution\n    fixed.pars = list(\n      mu = 0, # our mu (intercept)\n      ar1 = 0, # our phi_1 (AR(1) parameter of mu_t)\n      ma1 = 0, # our theta_1 (MA(1) parameter of mu_t)\n      omega = (20^2/252)*(1-0.1-0.8), # our alpha_0 (intercept)\n      alpha1 = 0.1, # our alpha_1 (ARCH(1) parameter of sigma_t^2)\n      beta1 = 0.8, # our beta_1 (GARCH(1) parameter of sigma_t^2)\n      shape = 8)) # d.o.f. nu for standardized t_nu innovations\n\n\nHigh persistence with Gaussian Distribution\n\nConsider the following GARCH(1, 1) process for the returns:\n\n\\[\n\\begin{cases}\n\\epsilon_{t} = \\sigma_{t} \\eta_{t} \\ , \\quad \\eta_{t} \\thicksim t_{500} \\\\\n\\sigma_{t}^{2} = \\frac{20^2}{252} + 0.10\\epsilon_{t-1}^{2} + 0.89\\sigma_{t-1}^{2}\n\\end{cases}\n\\]\ngarch_high_persistence_normal <-\n  ugarchspec(\n    mean.model = list(armaOrder = c(0,0), include.mean = FALSE), # ARMA order\n    variance.model = list(model = \"sGARCH\", garchOrder = c(1,1)), # GARCH order\n    distribution.model = \"std\", # Innovation distribution\n    fixed.pars = list(\n      mu = 0, # our mu (intercept)\n      ar1 = 0, # our phi_1 (AR(1) parameter of mu_t)\n      ma1 = 0, # our theta_1 (MA(1) parameter of mu_t)\n      omega = (20^2/252)*(1-0.1-0.89), # our alpha_0 (intercept)\n      alpha1 = 0.1, # our alpha_1 (ARCH(1) parameter of sigma_t^2)\n      beta1 = 0.89, # our beta_1 (GARCH(1) parameter of sigma_t^2)\n      shape = 500)) # d.o.f. nu for standardized t_nu innovations\n\n\nHigh persistence with t-Student distribution\n\nConsider the following GARCH(1, 1) process for the returns:\n\n\\[\n\\begin{cases}\n\\epsilon_{t} = \\sigma_{t} \\eta_{t} \\ , \\quad \\eta_{t} \\thicksim t_{8} \\\\\n\\sigma_{t}^{2} = \\frac{20^2}{252} + 0.10\\epsilon_{t-1}^{2} + 0.89\\sigma_{t-1}^{2}\n\\end{cases}\n\\]\ngarch_high_persistence_t <-\n  ugarchspec(\n    mean.model = list(armaOrder = c(0,0), include.mean = FALSE), # ARMA order\n    variance.model = list(model = \"sGARCH\", garchOrder = c(1,1)), # GARCH order\n    distribution.model = \"std\", # Innovation distribution\n    fixed.pars = list(\n      mu = 0, # our mu (intercept)\n      ar1 = 0, # our phi_1 (AR(1) parameter of mu_t)\n      ma1 = 0, # our theta_1 (MA(1) parameter of mu_t)\n      omega = (20^2/252)*(1-0.1-0.89), # our alpha_0 (intercept)\n      alpha1 = 0.1, # our alpha_1 (ARCH(1) parameter of sigma_t^2)\n      beta1 = 0.89, # our beta_1 (GARCH(1) parameter of sigma_t^2)\n      shape = 8)) # d.o.f. nu for standardized t_nu innovations"
  },
  {
    "objectID": "Simulation Results.html#computing-the-risk-measures",
    "href": "Simulation Results.html#computing-the-risk-measures",
    "title": "Simulation Results",
    "section": "Computing the risk measures",
    "text": "Computing the risk measures\nrisk.measures <- lapply(1:length(garch_simulation), function(i){\n  \n  garch.data = get(garch_simulation[i])\n  \n  garch.model = get(garch_model[i])\n\n  garch.risk <- lapply(1:10000,function(j){\n    \n    # Simulation\n    \n    returns = garch.data@path$seriesSim[,j]\n    \n    volatility = garch.data@path$sigmaSim[,j]\n    \n    residuals = garch.data@path$residSim[,j]\n    \n    std.residuals = (returns/volatility)\n    \n    # QMLE\n    \n    qmle.garch = garchx(y = returns, order = c(1,1))\n    \n    qmle.std.residuals = as.numeric(residuals.garchx(qmle.garch))\n    \n    # MLE\n    \n    mle.garch = ugarchfit(\n      spec = \n        ugarchspec(\n          mean.model = list(armaOrder = c(0,0), include.mean = FALSE), # ARMA order #\n          variance.model = \n            list(model = \"sGARCH\",garchOrder = c(1,1)), # GARCH order #\n          distribution.model = \"std\"), # Innovation distribution #\n      data = returns,\n      solver = 'hybrid')\n    \n    mle.std.residuals = as.numeric(residuals(mle.garch,standardize = TRUE))\n    \n    # Bootstrap \n    \n    garch.bootstrap =\n      bootstrap(fitORspec = mle.garch,\n                    data = returns,\n                    n.bootfit = 1,\n                    n.bootpred = 1,\n                    n.ahead = 1,\n                    rseed = c(1,2),\n                    solver = \"hybrid\",\n                    solver.control = list(), fit.control = list(),\n                    external.forecasts =  list(mregfor = NULL, vregfor = NULL),\n                    mexsimdata = NULL, vexsimdata = NULL)\n\n    boot.std.residuals = garch.bootstrap$boot.std.residuals\n\n    garch.results =\n      tibble(\n        id_simulation = j,\n        sim.std.residuals = std.residuals,\n        qmle.std.residuals = qmle.std.residuals,\n        mle.std.residuals = mle.std.residuals,\n        boot.std.residuals = boot.std.residuals) %>% \n      pivot_longer(-id_simulation, names_to = \"risk.measure\", values_to = \"residuals\") %>% \n      group_by(id_simulation,risk.measure) %>% \n      summarise_at(vars(residuals),\n                   .funs = list(\n                     quantile_0.010  = ~ quantile(., probs = 0.010),\n                     quantile_0.025  = ~ quantile(., probs = 0.025),\n                     quantile_0.050  = ~ quantile(., probs = 0.050),\n                     quantile_0.100  = ~ quantile(., probs = 0.100),\n                     quantile_0.250  = ~ quantile(., probs = 0.250),\n                     quantile_0.500  = ~ quantile(., probs = 0.500),\n                     expectile_0.010  = ~ expectile(., probs = 0.010),\n                     expectile_0.025  = ~ expectile(., probs = 0.025),\n                     expectile_0.050  = ~ expectile(., probs = 0.050),\n                     expectile_0.100  = ~ expectile(., probs = 0.100),\n                     expectile_0.250  = ~ expectile(., probs = 0.250),\n                     expectile_0.500  = ~ expectile(., probs = 0.500),\n                     extremile_0.010  = ~ extremile(., probs = 0.010),\n                     extremile_0.025  = ~ extremile(., probs = 0.025),\n                     extremile_0.050  = ~ extremile(., probs = 0.050),\n                     extremile_0.100  = ~ extremile(., probs = 0.100),\n                     extremile_0.250  = ~ extremile(., probs = 0.250),\n                     extremile_0.500  = ~ extremile(., probs = 0.500)\n                     )) %>% \n      ungroup()   \n\n    return(tryCatch(garch.results, error = function(e) NULL)) \n\n  })\n  \n  garch.risk = \n    garch.risk %>% \n    bind_rows() %>% \n    mutate(data = garch_simulation[i],\n           model = garch_model[i])\n\n  rm(garch.data,garch.model)\n\n  gc()\n  \n    return(tryCatch(garch.risk, error = function(e) NULL)) \n  \n  })"
  },
  {
    "objectID": "Simulation Results.html#bootstrap-procedure",
    "href": "Simulation Results.html#bootstrap-procedure",
    "title": "Simulation Results",
    "section": "Bootstrap procedure",
    "text": "Bootstrap procedure\n\nWe follow the bootstrap method of Pascual, Romo, and Ruiz (2006).\nEstimate GARCH by ML and compute the standardized residuals \\(\\hat{\\eta}_{t}^{*} = \\epsilon_{t}^{*}/\\sigma_{t}^{*}\\)\nGenerate bootstrap samples: \\(\\epsilon_{t}^{*}=\\eta_{t}^{*} \\widehat{\\sigma}_{t}^{*}\\), with \\(\\widehat{\\sigma}_{t}^{* 2}=\\widehat{\\omega}+\\widehat{\\alpha} L_{t-1}^{* 2}+\\widehat{\\beta} \\widehat{\\sigma}_{t-1}^{* 2}\\) where \\(\\eta_{t}^{*}\\) are random draws with replacement from \\(\\widehat{F}_{\\hat{\\eta}_{t}^{*}}\\) and \\(\\widehat{\\sigma}_{1}^{*2}= \\widehat{\\sigma}_{1}^{2}=\\widehat{\\omega} /(1-\\widehat{\\alpha}-\\widehat{\\beta})\\).\nCompute MLE for each bootstrap sample: \\(\\widehat{\\theta}^{*}=\\left(\\widehat{\\omega}^{*}, \\widehat{\\alpha}^{*}, \\widehat{\\beta}^{*}\\right)\\).\nCompute the standard residuals: \\(\\hat{\\eta}_{t}^{*} = \\epsilon_{t}^{*}/\\sigma_{t}^{*}\\)\n\nbootstrap = function(fitORspec, data = NULL, n.ahead = 10,\n                     n.bootfit = 100, n.bootpred = 500, rseed = NA, \n                     solver = \"solnp\", solver.control = list(), fit.control = list(), \n                     external.forecasts =  list(mregfor = NULL, vregfor = NULL), \n                     mexsimdata = NULL, vexsimdata = NULL){\n  \n  require(xts)\n\n  fit = fitORspec\n  \n  model = fit@model\n  \n  vmodel = fit@model$modeldesc$vmodel\n  \n  m = model$maxOrder\n  \n  data = model$modeldata$data\n  \n  N = model$modeldata$T\n  \n  ns = model$n.start\n  \n  if(is.na(rseed[1])){\n    sseed1 = NA\n    sseed2 = NA\n  } else{\n    if(length(rseed) < n.bootpred){\n      stop(\"\\nugarchboot-->error: seed length must equal n.bootpred + n.bootfit for full method\\n\")\n    } else {\n      sseed = rseed\n      sseed1 = sseed[1:n.bootfit]\n      sseed2 = sseed[(n.bootfit+1):(n.bootpred + n.bootfit)]\n    }\n  }\n  \n  # generate paths of equal length to data based on empirical re-sampling of z\n  # Pascual, Romo and Ruiz (2006) p.2296 equation (5)\n  \n  fz = fit@fit$z\n  \n  empz = matrix(sample(fz, N, replace = TRUE), ncol = n.bootfit, nrow = N)\n\n  # presigma uses the same starting values as the original fit\n  # in paper they use alternatively the unconditional long run sigma \n  # Pascual, Romo and Ruiz (2006) p.2296 equation (5) (P.2296 paragraph 2  \"...marginal variance...\"\n  \n  paths = ugarchsim(fit, n.sim = N, m.sim = n.bootfit, \n                    presigma = tail(fit@fit$sigma, m), \n                    prereturns = tail(model$modeldata$data[1:N], m), \n                    preresiduals = tail(residuals(fit), m), \n                    startMethod = \"sample\", \n                    custom.dist = list(name = \"sample\", distfit = as.matrix(empz)),\n                    rseed = sseed1, mexsimdata = mexsimdata, vexsimdata = vexsimdata)\n  \n  fitlist = vector(mode = \"list\", length = n.bootfit)\n  \n  simseries = fitted(paths)\n  \n  spec = getspec(fit)\n  \n  # help the optimization with good starting parameters\n  \n  spec@model$start.pars = as.list(coef(fit))\n  \n  nx = NCOL(simseries)\n  \n  # get the distribution of the parameters (by fitting to the new path data)\n  #-------------------------------------------------------------------------\n  \n  fitlist = \n    ugarchfit(\n      spec = spec,\n      data = xts(as.numeric(simseries), as.Date(1:NROW(data), origin=\"1970-01-01\")),\n      solver = solver,\n      fit.control = fit.control, \n      solver.control = solver.control)\n    \n  boot.std.residuals = as.data.frame(residuals(fitlist, standardize = TRUE))\n  \n  ans = list(boot.std.residuals = boot.std.residuals)\n  \n  return(ans)\n  \n}"
  }
]